import React, { useEffect, useMemo, useState, useRef, useCallback, Suspense, lazy } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Badge } from "@/components/ui/badge";
import { Progress } from "@/components/ui/progress";
import { Timer, Target, Shuffle, Flag, History, Trophy, Compass, X, ArrowLeft, Loader2, Calendar, Eye, EyeOff, ArrowRight, CheckCircle2, ChevronRight, ChevronLeft, ChevronDown, ChevronUp, HelpCircle, Users, Share2, Edit2, Sparkles, Heart } from "lucide-react";
import confetti from "canvas-confetti";
import { ThemeSwitcher } from "@/components/ThemeSwitcher";
import { useTheme } from "@/contexts/ThemeContext";
import { supabase, LEADERBOARD_TABLE, DAILY_CHALLENGES_TABLE } from "@/lib/supabase";
import { getOrCreateUsername, getStoredUsername, setStoredUsername, hasSubmittedToday, markSubmittedToday, isUsernameAutoGenerated } from "@/lib/username";
import { trackGameStart, trackGameCompletion, updateGameHistory, updateUsernameAcrossTables, trackZenModeSolutionViewed } from "@/lib/gameAnalytics";
import { Leaderboard } from "@/components/Leaderboard";
import { YesterdayChallenge } from "@/components/YesterdayChallenge";
import { YesterdaySolution } from "@/components/YesterdaySolution";
import { fetchYesterdayChallengeData } from "@/lib/challengeUtils";
import { HeroSection } from "@/components/HeroSection";
import { GameModeTiles } from "@/components/GameModeTiles";
import { UserStatsBar } from "@/components/UserStatsBar";
import { SettingsPanel } from "@/components/SettingsPanel";
import { YesterdaysTopPlayers } from "@/components/YesterdaysTopPlayers";
import { WikipediaArticleViewer } from "@/components/game/WikipediaArticleViewer";
import { fetchPracticeGames, checkAllZenModeGameStatuses, fetchPracticeGameSummaries, updateZenModeCompletedCount, areAllZenModeGamesCompleted } from "@/lib/zenModeUtils";
// Lazy load heavy components for better initial load performance (especially on mobile)
const GameResults = lazy(() => import("@/components/game/GameResults").then(module => ({ default: module.GameResults })));
const ChallengeScreen = lazy(() => import("@/components/game/ChallengeScreen").then(module => ({ default: module.ChallengeScreen })));
const Onboarding = lazy(() => import("@/components/game/Onboarding").then(module => ({ default: module.Onboarding })));
const ScoringMethodology = lazy(() => import("@/components/game/ScoringMethodology").then(module => ({ default: module.ScoringMethodology })));
const GameSetup = lazy(() => import("@/components/game/GameSetup").then(module => ({ default: module.GameSetup })));
const ZenModeSelection = lazy(() => import("@/components/game/ZenModeSelection").then(module => ({ default: module.ZenModeSelection })));
const ZenModeSolution = lazy(() => import("@/components/game/ZenModeSolution").then(module => ({ default: module.ZenModeSolution })));
import { prettyTime, formatCountdown } from "@/lib/timeUtils";
import { getDailyChallengeGradient, getDateString, CATEGORIES } from "@/lib/gameConstants";

// --- Utilities ---
const API = "https://en.wikipedia.org/w/api.php?origin=*";

// Simple in-memory cache with TTL (Time To Live)
class SimpleCache {
  constructor(ttlMs = 3600000) { // Default 1 hour
    this.cache = new Map();
    this.ttlMs = ttlMs;
  }

  get(key) {
    const item = this.cache.get(key);
    if (!item) return null;
    
    if (Date.now() > item.expiry) {
      this.cache.delete(key);
      return null;
    }
    
    return item.value;
  }

  set(key, value) {
    this.cache.set(key, {
      value,
      expiry: Date.now() + this.ttlMs
    });
  }

  clear() {
    this.cache.clear();
  }
}

// Create cache instances for different data types
const summaryCache = new SimpleCache(3600000); // 1 hour
const linksCache = new SimpleCache(3600000); // 1 hour
const htmlCache = new SimpleCache(3600000); // 1 hour

// Daily Challenge utilities
function hashString(str) {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash; // Convert to 32bit integer
  }
  return Math.abs(hash);
}

function seededRandom(seed) {
  // Simple seeded random number generator (Linear Congruential Generator)
  let value = seed;
  return function() {
    value = (value * 9301 + 49297) % 233280;
    return value / 233280;
  };
}

function getDailyChallengeSeeds() {
  const dateStr = getDateString();
  const baseHash = hashString(dateStr);
  return {
    startSeed: baseHash,
    goalSeed: hashString(dateStr + '_goal'),
  };
}

function getTimeUntilMidnight() {
  const now = new Date();
  const midnight = new Date(now);
  midnight.setHours(24, 0, 0, 0);
  return midnight.getTime() - now.getTime();
}

// Special category mappings for categories that should fetch from multiple related categories
const CATEGORY_EXPANSIONS = {
};

/**
 * Validates if an article is suitable for the game:
 * - Has at least one link
 * - Is not a redirect or soft redirect
 * - Has valid content
 */
async function isValidArticle(title) {
  if (!title) return false;
  
  try {
    // First check if article has links (this is the most important check)
    const links = await fetchLinks(title);
    if (!links || links.length === 0) {
      return false;
    }
    
    // Check summary for redirect indicators
    const summary = await fetchSummary(title);
    if (!summary) return false;
    
    // Check for redirect indicators in description or extract
    const description = (summary.description || '').toLowerCase().trim();
    const extract = (summary.extract || '').toLowerCase().trim();
    
    // Check for soft redirect indicators - be more specific
    // Look for phrases that indicate a redirect, not just mentions of other wikis
    const softRedirectPatterns = [
      /^soft redirect/i,
      /^redirect to/i,
      /^this page redirects/i,
      /soft redirect to/i,
      /redirects to wiktionary/i,
      /redirects to wikisource/i,
      /redirects to wikibooks/i,
      /redirects to wikiquote/i,
      /redirects to wikinews/i,
      /redirects to wikiversity/i,
      /redirects to wikimedia commons/i,
      /redirects to wikidata/i,
      /redirects to wikivoyage/i,
    ];
    
    const hasSoftRedirect = softRedirectPatterns.some(pattern => 
      pattern.test(description) || pattern.test(extract)
    );
    
    if (hasSoftRedirect) {
      return false;
    }
    
    // Also check if description or extract is very short and mentions redirect
    // Some soft redirects might not have the exact pattern but have very short content
    if ((description.length < 50 || extract.length < 100) && 
        (description.includes('redirect') || extract.includes('redirect'))) {
      return false;
    }
    
    return true;
  } catch (e) {
    console.error(`Error validating article ${title}:`, e);
    return false;
  }
}

async function fetchRandomTitle(maxRetries = 10) {
  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      const url = `${API}&action=query&list=random&rnnamespace=0&rnlimit=1&format=json`;
      const res = await fetch(url);
      const data = await res.json();
      const title = data?.query?.random?.[0]?.title;
      
      if (title && await isValidArticle(title)) {
        return title;
      }
    } catch (e) {
      console.error(`Error fetching random title (attempt ${attempt + 1}):`, e);
    }
  }
  
  // If all retries failed, return null
  console.warn('Failed to find valid random article after', maxRetries, 'attempts');
  return null;
}

async function fetchRandomTitleFromCategory(categoryName, seed = null, maxRetries = 20) {
  if (!categoryName) return null;
  
  // Check if this category has expansions (multiple related categories)
  const categoriesToFetch = CATEGORY_EXPANSIONS[categoryName] || [categoryName];
  
  // Limit to first 7 categories for speed (or all if less than 7)
  const limitedCategories = categoriesToFetch.slice(0, 7);
  
  // Fetch articles from categories in parallel for speed
  const fetchPromises = limitedCategories.map(async (cat) => {
    const categoryUrl = `${API}&action=query&list=categorymembers&cmtitle=Category:${encodeURIComponent(cat)}&cmlimit=100&cmnamespace=0&format=json`;
    
    try {
      const res = await fetch(categoryUrl);
      const data = await res.json();
      const members = data?.query?.categorymembers || [];
      
      // Filter to only articles (not subcategories or files)
      const articles = members
        .filter(m => m.ns === 0) // ns=0 means main namespace (articles)
        .map(m => m.title);
      
      return articles;
    } catch (e) {
      console.error(`Error fetching articles from category ${cat}:`, e);
      return [];
    }
  });
  
  // Wait for all fetches to complete (in parallel)
  const results = await Promise.all(fetchPromises);
  
  // Flatten and remove duplicates
  let allArticles = [...new Set(results.flat())];
  
  // Sort articles for deterministic selection
  allArticles.sort();
  
  if (allArticles.length === 0) return null;
  
  // Try to find a valid article
  // For deterministic selection (with seed), we'll try articles in order
  // For random selection, we'll shuffle and try
  let articlesToTry = [...allArticles];
  
  if (seed !== null) {
    // Deterministic: use seed to select starting point, then try sequentially
    const rng = seededRandom(seed);
    const startIndex = Math.floor(rng() * articlesToTry.length);
    articlesToTry = [...articlesToTry.slice(startIndex), ...articlesToTry.slice(0, startIndex)];
  } else {
    // Random: shuffle the array
    for (let i = articlesToTry.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [articlesToTry[i], articlesToTry[j]] = [articlesToTry[j], articlesToTry[i]];
    }
  }
  
  // Try articles until we find a valid one
  const maxAttempts = Math.min(maxRetries, articlesToTry.length);
  for (let i = 0; i < maxAttempts; i++) {
    const title = articlesToTry[i];
    if (await isValidArticle(title)) {
      return title;
    }
  }
  
  // If no valid article found, return null
  console.warn(`No valid article found in category ${categoryName} after ${maxAttempts} attempts`);
  return null;
}

async function fetchDailyChallengeArticles() {
  const dateStr = getDateString();
  
  try {
    // Fetch daily challenge from Supabase
    const { data, error } = await supabase
      .from(DAILY_CHALLENGES_TABLE)
      .select('start_title, goal_title, hint')
      .eq('date', dateStr)
      .single();
    
    if (error) {
      console.error('Error fetching daily challenge:', error);
      throw error;
    }
    
    if (!data || !data.start_title || !data.goal_title) {
      throw new Error('Daily challenge not found for today');
    }
    
    return {
      startTitle: data.start_title,
      goalTitle: data.goal_title,
      hint: data.hint || null,
    };
  } catch (err) {
    console.error('Failed to fetch daily challenge from Supabase:', err);
    // Fallback: return error so UI can handle it
    throw new Error('Failed to load daily challenge. Please try again later.');
  }
}

async function fetchLinks(title) {
  // Check cache first
  const cacheKey = `links:${title}`;
  const cached = linksCache.get(cacheKey);
  if (cached) return cached;

  let allLinks = [];
  let continueToken = null;
  const MAX_LINKS = 2000;
  
  try {
  do {
    let url = `${API}&action=query&prop=links&plnamespace=0&pllimit=500&format=json&titles=${encodeURIComponent(title)}`;
    if (continueToken) {
      url += `&plcontinue=${encodeURIComponent(continueToken)}`;
    }
    
    const res = await fetch(url);
      if (!res.ok) return [];
      
    const data = await res.json();
    const pages = data?.query?.pages || {};
    const firstPage = Object.values(pages)[0];
      
      // Check if page is missing (non-existent article)
      if (firstPage?.missing !== undefined) {
        return [];
      }
      
    const links = (firstPage?.links || []).map((l) => l.title);
    allLinks = allLinks.concat(links);
    
    // Stop if we've reached the limit
    if (allLinks.length >= MAX_LINKS) {
      allLinks = allLinks.slice(0, MAX_LINKS);
      break;
    }
    
    // Check if there are more results
    continueToken = data?.continue?.plcontinue || null;
  } while (continueToken);
  
  // Cache the result
  linksCache.set(cacheKey, allLinks);
  return allLinks;
  } catch (e) {
    console.error('Error fetching links:', e);
    return [];
  }
}

async function fetchArticleHTML(title) {
  // Check cache first
  const cacheKey = `html:${title}`;
  const cached = htmlCache.get(cacheKey);
  if (cached) return cached;

  // Fetch mobile HTML version which is cleaner and easier to style
  const url = `https://en.wikipedia.org/api/rest_v1/page/html/${encodeURIComponent(title)}`;
  try {
    const res = await fetch(url);
    if (!res.ok) return null;
    const html = await res.text();
    // Cache the result
    htmlCache.set(cacheKey, html);
    return html;
  } catch (e) {
    console.error('Error fetching article HTML:', e);
    return null;
  }
}

async function fetchSummary(title) {
  // Check cache first
  const cacheKey = `summary:${title}`;
  const cached = summaryCache.get(cacheKey);
  if (cached) return cached;

  const url = `https://en.wikipedia.org/api/rest_v1/page/summary/${encodeURIComponent(title)}`;
  try {
  const res = await fetch(url);
  if (!res.ok) return null;
  const data = await res.json();
  const summary = {
    title: data.title,
    description: data.description,
    extract: data.extract,
    thumbnail: data.thumbnail?.source || null,
    url: data.content_urls?.desktop?.page || `https://en.wikipedia.org/wiki/${encodeURIComponent(title)}`,
  };
  // Cache the result
  summaryCache.set(cacheKey, summary);
  return summary;
  } catch (e) {
    console.error('Error fetching article summary:', e);
    return null;
  }
}

function useTimer(active) {
  const [start, setStart] = useState(null);
  const [now, setNow] = useState(null);
  useEffect(() => {
    let id;
    if (active) {
      const t0 = Date.now();
      setStart(t0);
      setNow(t0);
      id = setInterval(() => setNow(Date.now()), 1000);
    }
    return () => id && clearInterval(id);
  }, [active]);
  return start && now ? now - start : 0;
}

export default function WikipediaJourneyGame() {
  const { theme } = useTheme();
  
  // Setup
  const [startTitle, setStartTitle] = useState("");
  const [goalTitle, setGoalTitle] = useState("");
  const [startCategory, setStartCategory] = useState("");
  const [goalCategory, setGoalCategory] = useState("");
  const [startSummary, setStartSummary] = useState(null);
  const [goalSummary, setGoalSummary] = useState(null);
  const [currentTitle, setCurrentTitle] = useState(null);
  const [summary, setSummary] = useState(null);
  const [articleHTML, setArticleHTML] = useState(null);
  const [links, setLinks] = useState([]);
  const [history, setHistory] = useState([]);
  const [loading, setLoading] = useState(false);
  const [loadingStartRandom, setLoadingStartRandom] = useState(false);
  const [loadingGoalRandom, setLoadingGoalRandom] = useState(false);
  const [error, setError] = useState("");
  const [gameActive, setGameActive] = useState(false);
  const [won, setWon] = useState(false);
  const [dailyChallenge, setDailyChallenge] = useState(true); // Current mode: true = daily challenge mode, false = random/zen mode
  const [hasDailyChallenge, setHasDailyChallenge] = useState(false); // Whether a daily challenge exists for today
  const [showHomeScreen, setShowHomeScreen] = useState(true); // Whether to show the home screen with full tiles
  const [dailyChallengeHint, setDailyChallengeHint] = useState(null);
  const [isDailyChallengeCompleted, setIsDailyChallengeCompleted] = useState(false);
  const [timeUntilReset, setTimeUntilReset] = useState(getTimeUntilMidnight());
  const timer = useTimer(gameActive && !won);
  const dailyChallengeLoadedRef = useRef(false);
  
  // Refs for game state tracking
  const finalTime = useRef(0);
  const confettiTriggered = useRef(false);
  const gameSessionId = useRef(null);
  
  const [searchQuery, setSearchQuery] = useState("");
  const [debouncedSearchQuery, setDebouncedSearchQuery] = useState("");
  const [visibleLinksCount, setVisibleLinksCount] = useState(100);
  const [showArticleOnMobile, setShowArticleOnMobile] = useState(false);
  const [startingGame, setStartingGame] = useState(false);
  const [showOnboarding, setShowOnboarding] = useState(false);
  const [onboardingStep, setOnboardingStep] = useState(0);
  const [showScoringModal, setShowScoringModal] = useState(false);
  const [showLeaderboard, setShowLeaderboard] = useState(false);
  const [showSettings, setShowSettings] = useState(false);
  const [showUsernameModal, setShowUsernameModal] = useState(false);
  const [username, setUsername] = useState("");
  const [usernameInput, setUsernameInput] = useState("");
  const [submittingScore, setSubmittingScore] = useState(false);
  const [leaderboardRefreshKey, setLeaderboardRefreshKey] = useState(0);
  const [scoreSubmitted, setScoreSubmitted] = useState(false);
  const [pendingSubmission, setPendingSubmission] = useState(false);
  
  // Challenge state
  const [challengeData, setChallengeData] = useState(null);
  const [showChallengeScreen, setShowChallengeScreen] = useState(false);
  const [isChallengeMode, setIsChallengeMode] = useState(false);
  const [showScoreBreakdown, setShowScoreBreakdown] = useState(false);
  
  // Yesterday's challenge state
  const [yesterdayChallengeData, setYesterdayChallengeData] = useState(null);
  const [showYesterdaySolution, setShowYesterdaySolution] = useState(false);

  // Zen Mode state
  const [zenMode, setZenMode] = useState(false);
  const [zenModeGames, setZenModeGames] = useState([]);
  const [zenModeGameStatuses, setZenModeGameStatuses] = useState(new Map());
  const [zenModeGameSummaries, setZenModeGameSummaries] = useState({});
  const [showZenModeSelection, setShowZenModeSelection] = useState(false);
  const [selectedZenModeGame, setSelectedZenModeGame] = useState(null);
  const [showZenModeSolution, setShowZenModeSolution] = useState(false);
  const [zenModeSolutionData, setZenModeSolutionData] = useState(null);
  const [zenModeSolutionCompleted, setZenModeSolutionCompleted] = useState(false);
  const [loadingZenModeGames, setLoadingZenModeGames] = useState(false);
  const [isAllZenModeCompleted, setIsAllZenModeCompleted] = useState(false);

  // Progress heuristic: Jaccard similarity of words in titles (toy metric)
  const progress = useMemo(() => {
    if (!goalTitle || !currentTitle) return 0;
    const a = new Set(goalTitle.toLowerCase().split(/[^a-z0-9]+/).filter(Boolean));
    const b = new Set(currentTitle.toLowerCase().split(/[^a-z0-9]+/).filter(Boolean));
    const inter = [...a].filter((x) => b.has(x)).length;
    const union = new Set([...a, ...b]).size || 1;
    return Math.round((inter / union) * 100);
  }, [goalTitle, currentTitle]);

  const loadPage = useCallback(async (title, pushHistory = true) => {
    try {
      setLoading(true);
      setError("");
      
      // First fetch summary to get resolved title (handles redirects)
      const sum = await fetchSummary(title);
      
      // Check if article exists (summary will be null for non-existent articles)
      if (!sum) {
        setError(`The article "${title}" doesn't exist on Wikipedia. Please try another link.`);
        setLoading(false);
        return;
      }
      
      // Detect redirect: if resolved title differs from requested title, it's a redirect
      // Use resolved title for fetching links and HTML (not the redirect source)
      const resolvedTitle = sum.title;
      const [lks, html] = await Promise.all([
        fetchLinks(resolvedTitle),
        fetchArticleHTML(resolvedTitle)
      ]);
      
      setSummary(sum);
      setLinks(lks || []);
      setArticleHTML(html);
      setCurrentTitle(resolvedTitle);
      
      // Only add resolved title to history (skip redirect sources)
      // This ensures redirects don't count as separate steps
      if (pushHistory) setHistory((h) => [...h, resolvedTitle]);
    } catch (e) {
      console.error('Error loading page:', e);
      setError("Couldn't load the page. Try another link.");
    } finally {
      setLoading(false);
    }
  }, []);

  const handleLinkClick = useCallback((title) => {
    loadPage(title);
  }, [loadPage]);

  // Debounce search query to avoid filtering on every keystroke
  useEffect(() => {
    const timer = setTimeout(() => {
      setDebouncedSearchQuery(searchQuery);
    }, 250);
    return () => clearTimeout(timer);
  }, [searchQuery]);

  // Filter links based on debounced search query
  const filteredLinks = useMemo(() => {
    if (!debouncedSearchQuery.trim()) return links;
    const query = debouncedSearchQuery.toLowerCase();
    return links.filter(link => link.toLowerCase().includes(query));
  }, [links, debouncedSearchQuery]);

  // Paginated links for performance
  const visibleLinks = useMemo(() => {
    return filteredLinks.slice(0, visibleLinksCount);
  }, [filteredLinks, visibleLinksCount]);

  // Reset visible links count when links change
  useEffect(() => {
    setVisibleLinksCount(100);
  }, [links.length]);

  async function navigateToStep(stepIndex) {
    if (stepIndex < 0 || stepIndex >= history.length) return;
    const targetTitle = history[stepIndex];
    // Navigate to the clicked step as a new step (don't truncate history)
    await loadPage(targetTitle, true);
  }

  async function goBack() {
    if (history.length <= 1) return;
    const previousIndex = history.length - 2;
    const targetTitle = history[previousIndex];
    // Go back by truncating history and loading the previous page
    setHistory((h) => h.slice(0, previousIndex + 1));
    await loadPage(targetTitle, false);
  }

  // Fetch Zen Mode practice games
  async function fetchZenModeGames() {
    setLoadingZenModeGames(true);
    try {
      const games = await fetchPracticeGames();
      setZenModeGames(games);
      
      // Fetch summaries for all games (with caching)
      const summaries = await fetchPracticeGameSummaries(games);
      setZenModeGameSummaries(summaries);
      
      // Check completion status for all games
      const username = getStoredUsername() || 'anonymous';
      const statuses = await checkAllZenModeGameStatuses(username, games);
      setZenModeGameStatuses(statuses);
      
      // Update local storage count
      updateZenModeCompletedCount(statuses, games.length);
    } catch (err) {
      console.error('Failed to fetch Zen Mode games:', err);
      setError("Failed to load Zen Mode games. Please try again.");
    } finally {
      setLoadingZenModeGames(false);
    }
  }

  // Start Zen Mode - fetch games and show selection
  async function startZenMode() {
    setZenMode(true);
    setDailyChallenge(false);
    setShowZenModeSelection(true);
    await fetchZenModeGames();
  }

  // Select a Zen Mode game to play
  async function selectZenModeGame(game) {
    const status = zenModeGameStatuses.get(game.id);
    if (status !== 'available') {
      setError("This game has already been completed or solution viewed.");
      return;
    }

    setSelectedZenModeGame(game);
    setStartTitle(game.start_title);
    setGoalTitle(game.goal_title);
    setStartCategory("");
    setGoalCategory("");
    setDailyChallenge(false); // Ensure daily challenge is disabled
    setDailyChallengeHint(null);
    setShowZenModeSelection(false);
    
    // Start the game with Zen Mode game data directly
    await startZenModeGame(game);
  }

  // Start a Zen Mode game (separate function to avoid state timing issues)
  async function startZenModeGame(game) {
    setStartingGame(true);
    setWon(false);
    setHistory([]);
    setSummary(null);
    setLinks([]);
    setError("");
    setGameActive(false);
    setShowArticleOnMobile(false);
    setShowChallengeScreen(false);

    try {
      const s = game.start_title;
      const g = game.goal_title;
      
      setStartTitle(s);
      setGoalTitle(g);
      setStartCategory("");
      setGoalCategory("");
      setDailyChallenge(false);
      setDailyChallengeHint(null);
      
      // Fetch goal summary
      if (g) {
        await fetchSummary(g).then(setGoalSummary).catch(() => setGoalSummary(null));
      }
      
      // Track game start
      if (s && g) {
        const sessionId = await trackGameStart({
          startTitle: s,
          goalTitle: g,
          isDailyChallenge: false,
          isZenMode: true,
          startCategory: null,
          goalCategory: null,
        });
        gameSessionId.current = sessionId;
      }
      
      setGameActive(true);
      await loadPage(s);
    } catch (e) {
      setError("Failed to start game. Try again.");
    } finally {
      setStartingGame(false);
    }
  }

  // Handle forfeit in Zen Mode
  async function handleZenModeForfeit() {
    if (!zenMode || !selectedZenModeGame || !gameSessionId.current) {
      return;
    }

    // Mark solution as viewed
    await trackZenModeSolutionViewed(gameSessionId.current);
    
    // Show solution
    setZenModeSolutionData({
      start_title: selectedZenModeGame.start_title,
      goal_title: selectedZenModeGame.goal_title,
      solution_history: selectedZenModeGame.solution_history,
    });
    setZenModeSolutionCompleted(false);
    setShowZenModeSolution(true);
    setGameActive(false);
    setWon(false);
    
    // Refresh game statuses
    const username = getStoredUsername() || 'anonymous';
    const statuses = await checkAllZenModeGameStatuses(username, zenModeGames);
    setZenModeGameStatuses(statuses);
    // Update local storage count
    updateZenModeCompletedCount(statuses, zenModeGames.length);
  }

  async function startGame() {
    setStartingGame(true);
    setWon(false);
    setHistory([]);
    setSummary(null);
    setLinks([]);
    setError("");
    setGameActive(false);
    setShowArticleOnMobile(false);
    setShowChallengeScreen(false); // Hide challenge screen when starting game

    try {
      let s, g;
      
      // Check if we're in Zen Mode
      if (zenMode && selectedZenModeGame) {
        s = selectedZenModeGame.start_title;
        g = selectedZenModeGame.goal_title;
        setStartTitle(s);
        setGoalTitle(g);
        setStartCategory("");
        setGoalCategory("");
        setDailyChallenge(false);
        setDailyChallengeHint(null);
      } else if (isChallengeMode && challengeData) {
        // Use challenge articles
        s = challengeData.start;
        g = challengeData.end;
        setStartTitle(s);
        setGoalTitle(g);
        setStartCategory("");
        setGoalCategory("");
        setDailyChallenge(false); // Challenge mode overrides daily challenge
        setDailyChallengeHint(null);
      } else if (dailyChallenge) {
        // Daily Challenge mode: use date-based deterministic selection
        const dailyArticles = await fetchDailyChallengeArticles();
        s = dailyArticles.startTitle;
        g = dailyArticles.goalTitle;
        setStartTitle(s);
        setGoalTitle(g);
        setDailyChallengeHint(dailyArticles.hint);
        setStartCategory("");
        setGoalCategory("");
      } else {
        // Normal mode: use user selections or random
        s = startTitle;
      if (!s) {
        if (startCategory) {
          s = await fetchRandomTitleFromCategory(startCategory);
        } else {
          s = await fetchRandomTitle();
        }
        if (!s) {
          throw new Error("Failed to find a valid start article. Please try again or select a different category.");
        }
      }
      
        g = goalTitle;
      if (!g) {
        if (goalCategory) {
          g = await fetchRandomTitleFromCategory(goalCategory);
        } else {
          g = await fetchRandomTitle();
        }
        if (!g) {
          throw new Error("Failed to find a valid goal article. Please try again or select a different category.");
        }
      }
      
      setStartTitle(s);
      setGoalTitle(g);
      }
      
      // Fetch goal summary immediately when starting with random titles
      if (g) {
        await fetchSummary(g).then(setGoalSummary).catch(() => setGoalSummary(null));
      }
      
      // Track game start
      if (s && g) {
        const sessionId = await trackGameStart({
          startTitle: s,
          goalTitle: g,
          isDailyChallenge: dailyChallenge && !isChallengeMode && !zenMode, // Don't track challenge or zen mode as daily challenge
          isZenMode: zenMode,
          startCategory: startCategory || null,
          goalCategory: goalCategory || null,
        });
        gameSessionId.current = sessionId;
      }
      
      setGameActive(true);
      await loadPage(s);
    } catch (e) {
      setError("Failed to start game. Try again.");
    } finally {
      setStartingGame(false);
    }
  }

  function resetGame() {
    setStartingGame(false);
    // Clear start/goal titles when resetting random games (not daily challenge, challenge mode, or zen mode)
    if (!dailyChallenge && !isChallengeMode && !zenMode) {
    setStartTitle("");
    setGoalTitle("");
    setStartCategory("");
    setGoalCategory("");
    }
    setStartSummary(null);
    setGoalSummary(null);
    setCurrentTitle(null);
    setSummary(null);
    setArticleHTML(null);
    setLinks([]);
    setHistory([]);
    setGameActive(false);
    setWon(false);
    setError("");
    setLoadingStartRandom(false);
    setLoadingGoalRandom(false);
    setShowArticleOnMobile(false);
    setScoreSubmitted(false);
    setPendingSubmission(false);
    setShowScoreBreakdown(false); // Reset score breakdown collapse state
    gameSessionId.current = null; // Reset game session ID
    // Clear challenge data and URL params on reset
    if (isChallengeMode) {
      setChallengeData(null);
      setIsChallengeMode(false);
      setShowChallengeScreen(false);
      // Clear URL parameters
      window.history.replaceState({}, '', window.location.pathname);
    }
    // Reset Zen Mode state
    if (zenMode) {
      setSelectedZenModeGame(null);
      setShowZenModeSolution(false);
      setZenModeSolutionData(null);
      setZenModeSolutionCompleted(false);
      // Show selection screen again if not completed
      if (!showZenModeSelection) {
        setShowZenModeSelection(true);
      }
    }
    // Reset daily challenge loaded ref when resetting in daily challenge mode
    if (dailyChallenge) {
      dailyChallengeLoadedRef.current = false;
    }
  }

  // Switch to Random Game mode and generate new random articles
  async function switchToRandomGame() {
    // First reset the game state
    setStartingGame(false);
    setStartTitle("");
    setGoalTitle("");
    setDailyChallengeHint(null);
    setStartCategory("");
    setGoalCategory("");
    setStartSummary(null);
    setGoalSummary(null);
    setCurrentTitle(null);
    setSummary(null);
    setArticleHTML(null);
    setLinks([]);
    setHistory([]);
    setGameActive(false);
    setWon(false);
    setError("");
    setLoadingStartRandom(false);
    setLoadingGoalRandom(false);
    setShowArticleOnMobile(false);
    setScoreSubmitted(false);
    setPendingSubmission(false);
    gameSessionId.current = null;
    dailyChallengeLoadedRef.current = false;
    
    // Switch to Random Game mode
    setDailyChallenge(false);
    
    // Generate new random articles
    setLoadingStartRandom(true);
    setLoadingGoalRandom(true);
    try {
      const newStartTitle = await fetchRandomTitle();
      const newGoalTitle = await fetchRandomTitle();
      
      if (!newStartTitle) {
        setError("Failed to find a valid start article. Please try again.");
        return;
      }
      
      if (!newGoalTitle) {
        setError("Failed to find a valid goal article. Please try again.");
        return;
      }
      
      setStartTitle(newStartTitle);
      setGoalTitle(newGoalTitle);
      
      // Fetch summaries for both articles
      fetchSummary(newStartTitle).then(setStartSummary).catch(() => setStartSummary(null));
      fetchSummary(newGoalTitle).then(setGoalSummary).catch(() => setGoalSummary(null));
    } catch (e) {
      setError("Failed to generate random articles. Please try again.");
    } finally {
      setLoadingStartRandom(false);
      setLoadingGoalRandom(false);
    }
  }
  
  // Check if onboarding has been shown before
  useEffect(() => {
    const hasSeenOnboarding = localStorage.getItem('wikiGo-onboarding-seen');
    // Show challenge screen first if challenge params exist, then onboarding if needed
    if (challengeData && !hasSeenOnboarding) {
      // Delay onboarding until after challenge screen is dismissed
      return;
    }
    if (!hasSeenOnboarding && !challengeData) {
      setShowOnboarding(true);
    }
  }, [challengeData]);

  // Initialize username on mount
  useEffect(() => {
    const storedUsername = getStoredUsername();
    if (storedUsername) {
      setUsername(storedUsername);
    } else {
      // Generate and store username on first visit
      const newUsername = getOrCreateUsername();
      setUsername(newUsername);
    }
  }, []);

  // Parse challenge URL parameters on mount
  useEffect(() => {
    const params = new URLSearchParams(window.location.search);
    const challengeStart = params.get('start');
    const challengeEnd = params.get('end');
    const challengeMoves = params.get('moves');
    const challengeTime = params.get('time');
    const challengeScore = params.get('score');
    const challengeUsername = params.get('username');

    // Validate all required challenge parameters exist
    if (challengeStart && challengeEnd && challengeMoves && challengeTime && challengeScore && challengeUsername) {
      const data = {
        start: decodeURIComponent(challengeStart),
        end: decodeURIComponent(challengeEnd),
        moves: parseInt(challengeMoves, 10),
        time: parseInt(challengeTime, 10), // time in seconds
        score: parseInt(challengeScore, 10),
        username: decodeURIComponent(challengeUsername),
      };

      // Validate numeric values
      if (!isNaN(data.moves) && !isNaN(data.time) && !isNaN(data.score) && data.moves >= 0 && data.time >= 0 && data.score >= 0) {
        setChallengeData(data);
        setIsChallengeMode(true);
      }
    }
  }, []); // Only run on mount

  // Show challenge screen when challenge data is available and game is not active
  useEffect(() => {
    if (challengeData && isChallengeMode && !gameActive && !won && !showChallengeScreen && !showOnboarding && !startingGame) {
      setShowChallengeScreen(true);
    }
  }, [challengeData, isChallengeMode, gameActive, won, showChallengeScreen, showOnboarding, startingGame]);

  // Update document title based on game state
  useEffect(() => {
    if (won) {
      document.title = `ðŸŽ‰ Challenge Complete! - WikiGo`;
    } else if (gameActive) {
      const currentPage = currentTitle || startTitle || 'Playing';
      document.title = `${currentPage} â†’ ${goalTitle || 'Goal'} - WikiGo`;
    } else if (dailyChallenge) {
      document.title = `Daily Challenge: ${startTitle || 'Loading...'} â†’ ${goalTitle || 'Loading...'} - WikiGo`;
    } else {
      document.title = 'WikiGo - Navigate Wikipedia Articles in the Fewest Moves';
    }
  }, [won, gameActive, dailyChallenge, currentTitle, startTitle, goalTitle]);

  // Show username modal when Daily Challenge is won and username is auto-generated
  useEffect(() => {
    if (won && dailyChallenge && isUsernameAutoGenerated()) {
      setShowUsernameModal(true);
      setPendingSubmission(true);
    }
  }, [won, dailyChallenge]);
  
  // Update time until reset for Daily Challenge (only when UI is visible)
  useEffect(() => {
    if (!dailyChallenge) return;
    // Only update when leaderboard is shown or when not actively playing
    if (gameActive && !showLeaderboard) return;
    
    const interval = setInterval(() => {
      setTimeUntilReset(getTimeUntilMidnight());
    }, 1000);
    
    return () => clearInterval(interval);
  }, [dailyChallenge, gameActive, showLeaderboard]);
  
  // Check if daily challenge exists and load it when in daily challenge mode
  useEffect(() => {
    // Check if daily challenge exists (only check once on mount or when needed)
    if (!hasDailyChallenge && !dailyChallengeLoadedRef.current) {
      dailyChallengeLoadedRef.current = true;
      fetchDailyChallengeArticles().then(({ startTitle, goalTitle, hint }) => {
        setHasDailyChallenge(true);
        // Only set the titles if we're in daily challenge mode
        if (dailyChallenge && !gameActive && !startTitle && !goalTitle) {
          setStartTitle(startTitle);
          setGoalTitle(goalTitle);
          setDailyChallengeHint(hint);
        }
      }).catch(() => {
        setHasDailyChallenge(false);
        dailyChallengeLoadedRef.current = false;
      });
    }
    
    // Load daily challenge articles when mode is enabled
    if (dailyChallenge && hasDailyChallenge && !gameActive && !startTitle && !goalTitle) {
      fetchDailyChallengeArticles().then(({ startTitle, goalTitle, hint }) => {
        setStartTitle(startTitle);
        setGoalTitle(goalTitle);
        setDailyChallengeHint(hint);
      }).catch(() => {
        setError("Failed to load daily challenge. Try again.");
      });
    }
  }, [dailyChallenge, gameActive, startTitle, goalTitle, hasDailyChallenge]);

  // Check if today's daily challenge is completed
  useEffect(() => {
    if (dailyChallenge && !gameActive) {
      const dateString = getDateString();
      const completed = hasSubmittedToday(dateString) || (won && scoreSubmitted);
      setIsDailyChallengeCompleted(completed);
    } else if (!dailyChallenge) {
      setIsDailyChallengeCompleted(false);
    }
  }, [dailyChallenge, gameActive, won, scoreSubmitted]);

  // Load yesterday's challenge data on mount
  useEffect(() => {
    fetchYesterdayChallengeData().then(data => {
      setYesterdayChallengeData(data);
    }).catch(err => {
      console.error('Failed to load yesterday challenge:', err);
    });
  }, []);

  // Preload Zen Mode practice games and summaries on mount (for caching)
  useEffect(() => {
    async function preloadZenModeData() {
      try {
        const games = await fetchPracticeGames();
        if (games.length > 0) {
          // Fetch and cache summaries
          await fetchPracticeGameSummaries(games);
        }
      } catch (err) {
        // Silently fail - this is just preloading for cache
        console.debug('Failed to preload Zen Mode data:', err);
      }
    }
    preloadZenModeData();
  }, []);

  // Check if all Zen Mode games are completed
  useEffect(() => {
    if (zenModeGames.length > 0) {
      const allCompleted = areAllZenModeGamesCompleted(zenModeGames.length);
      setIsAllZenModeCompleted(allCompleted);
    } else {
      setIsAllZenModeCompleted(false);
    }
  }, [zenModeGames, zenModeGameStatuses]);

  useEffect(() => {
    if (currentTitle && goalTitle && gameActive) {
      // Normalize titles for comparison (case-insensitive, trim whitespace)
      const normalizedCurrent = currentTitle.trim().toLowerCase();
      const normalizedGoal = goalTitle.trim().toLowerCase();
      
      if (normalizedCurrent === normalizedGoal) {
        // Capture timer value BEFORE setting won to true to avoid race condition
        // The timer stops when won becomes true, so we need to capture it synchronously
        finalTime.current = timer;
        setWon(true);
        setGameActive(false);
      }
    }
  }, [currentTitle, goalTitle, gameActive, timer]);

  // Fetch summaries for start and goal pages when titles change
  useEffect(() => {
    if (startTitle && !gameActive) {
      fetchSummary(startTitle).then(setStartSummary).catch(() => setStartSummary(null));
    } else if (!startTitle) {
      setStartSummary(null);
    }
  }, [startTitle, gameActive]);

  useEffect(() => {
    if (goalTitle) {
      // Fetch goal summary whenever goalTitle changes, regardless of gameActive state
      fetchSummary(goalTitle).then(setGoalSummary).catch(() => setGoalSummary(null));
    } else {
      setGoalSummary(null);
    }
  }, [goalTitle]);

  const moveCount = history.length ? history.length - 1 : 0;

  // Update game history in database at each step
  useEffect(() => {
    if (gameActive && gameSessionId.current && history.length > 0) {
      // Debounce updates to avoid too many database calls
      const timeoutId = setTimeout(() => {
        updateGameHistory(gameSessionId.current, history).catch(err => {
          console.error('Failed to update game history:', err);
        });
      }, 500); // Wait 500ms after history change before updating

      return () => clearTimeout(timeoutId);
    }
  }, [history, gameActive]);

  // Calculate score: 1000 âˆ’ (10 Ã— moves) âˆ’ (1 Ã— seconds)
  const finalScore = useMemo(() => {
    if (!won) return 0;
    // Use finalTime.current if set, otherwise use current timer value
    const timeToUse = finalTime.current > 0 ? finalTime.current : timer;
    const seconds = Math.floor(timeToUse / 1000);
    return Math.max(0, 1000 - (10 * moveCount) - seconds);
  }, [won, moveCount, timer]);

  // Trigger confetti when game is won
  useEffect(() => {
    if (won && !confettiTriggered.current) {
      confettiTriggered.current = true;
      // finalTime.current is already set when won becomes true, so we don't need to set it again here
      // But ensure it's set if somehow it wasn't captured earlier
      if (finalTime.current === 0 && timer > 0) {
      finalTime.current = timer;
      }
      
      // Track game completion
      const timeToUse = finalTime.current;
      const score = finalScore;
      trackGameCompletion(gameSessionId.current, {
        score: score,
        moves: moveCount,
        timeMs: timeToUse,
        history: history,
      }).catch(err => {
        console.error('Failed to track game completion:', err);
      });
      
      // Handle Zen Mode completion
      if (zenMode && selectedZenModeGame) {
        // Don't show solution modal for completed games - just refresh statuses
        // Clear any solution modal state to ensure it doesn't interfere
        setShowZenModeSolution(false);
        setZenModeSolutionData(null);
        setZenModeSolutionCompleted(false);
        
        // Refresh game statuses
        const username = getStoredUsername() || 'anonymous';
        checkAllZenModeGameStatuses(username, zenModeGames).then(statuses => {
          setZenModeGameStatuses(statuses);
          // Update local storage count
          updateZenModeCompletedCount(statuses, zenModeGames.length);
        });
      }
      
      // Confetti animation
      const duration = 3000;
      const animationEnd = Date.now() + duration;
      const defaults = { startVelocity: 30, spread: 360, ticks: 60, zIndex: 0 };

      function randomInRange(min, max) {
        return Math.random() * (max - min) + min;
      }

      const interval = setInterval(function() {
        const timeLeft = animationEnd - Date.now();

        if (timeLeft <= 0) {
          return clearInterval(interval);
        }

        const particleCount = 50 * (timeLeft / duration);
        confetti({
          ...defaults,
          particleCount,
          origin: { x: randomInRange(0.1, 0.3), y: Math.random() - 0.2 }
        });
        confetti({
          ...defaults,
          particleCount,
          origin: { x: randomInRange(0.7, 0.9), y: Math.random() - 0.2 }
        });
      }, 250);

      // Cleanup interval
      return () => {
        clearInterval(interval);
      };
    }
  }, [won, timer, finalScore, moveCount, history, zenMode, selectedZenModeGame, zenModeGames]);

  // Reset confetti trigger when game resets
  useEffect(() => {
    if (!won) {
      confettiTriggered.current = false;
      finalTime.current = 0;
    }
  }, [won]);

  // Submit score to leaderboard
  async function submitToLeaderboard() {
    // Don't submit Zen Mode games to leaderboard
    if (!dailyChallenge || !won || zenMode) return;
    
    const dateString = getDateString();
    
    // Check if already submitted today
    if (hasSubmittedToday(dateString)) {
      return;
    }

    const currentUsername = getStoredUsername() || getOrCreateUsername();
    const score = finalScore;
    const moves = moveCount;
    const timeMs = finalTime.current;

    try {
      setSubmittingScore(true);
      
      const { error } = await supabase
        .from(LEADERBOARD_TABLE)
        .insert([
          {
            username: currentUsername,
            score: score,
            moves: moves,
            time_ms: timeMs,
            date: dateString,
            start_title: startTitle,
            goal_title: goalTitle,
            history: history,
          },
        ]);

      if (error) {
        console.error('Error submitting score:', error);
        // Don't show error to user, just log it
      } else {
        // Mark as submitted
        markSubmittedToday(dateString);
        setScoreSubmitted(true);
        setPendingSubmission(false);
        // Refresh leaderboard if it's open
        setLeaderboardRefreshKey(prev => prev + 1);
      }
    } catch (err) {
      console.error('Error submitting to leaderboard:', err);
    } finally {
      setSubmittingScore(false);
    }
  }

  // Submit score when Daily Challenge is won (but wait if username needs confirmation)
  useEffect(() => {
    if (won && dailyChallenge && finalTime.current > 0 && !pendingSubmission && !scoreSubmitted) {
      submitToLeaderboard();
    }
  }, [won, dailyChallenge, finalScore, pendingSubmission, scoreSubmitted]);

  // --- UI ---
  return (
    <div className={`w-full p-4 md:p-6 lg:p-8 ${
      theme === 'dark' 
        ? 'bg-gray-950' 
        : theme === 'classic'
        ? 'bg-[#f5f5f0]'
        : 'bg-gradient-to-b from-slate-50 to-white'
    }`}>
      <div className="mx-auto max-w-4xl lg:max-w-6xl xl:max-w-7xl 2xl:max-w-[90rem] space-y-4">
        <header className="flex flex-row items-center justify-between gap-3 sm:gap-4">
          <div className="flex-shrink-0 min-w-0 flex items-center">
            <div className="flex items-center gap-2 sm:gap-3 flex-nowrap">
              <h1 className={`text-2xl sm:text-3xl font-bold tracking-tight flex items-center gap-1.5 sm:gap-2 whitespace-nowrap ${
                theme === 'dark' ? 'text-white' : theme === 'classic' ? 'text-black font-serif' : 'text-slate-900'
              }`}>
                <Compass className="h-6 w-6 sm:h-7 sm:w-7 flex-shrink-0" /> <span className="whitespace-nowrap">WikiGo</span>
              </h1>
              {dailyChallenge && (
                <Badge variant="default" className="flex items-center gap-1 text-xs sm:text-sm flex-shrink-0 ml-1">
                  <Calendar className="h-3 w-3" />
                  <span className="hidden xs:inline">Daily Challenge</span>
                  <span className="xs:hidden">Daily</span>
                </Badge>
              )}
            </div>
          </div>
          <div className="flex gap-2 sm:gap-2 items-center justify-end flex-shrink-0">
            <Button
              variant="ghost"
              onClick={() => {
                setShowLeaderboard(true);
                setLeaderboardRefreshKey(prev => prev + 1);
              }}
              className="h-9 sm:h-10 px-2 sm:px-4 text-xs sm:text-sm min-w-[44px] sm:min-w-0"
              title="View leaderboard"
            >
              <Users className="h-4 w-4 sm:h-5 sm:w-5 mr-1.5 sm:mr-2" />
              <span className="hidden sm:inline">Leaderboard</span>
              <span className="sm:hidden">Board</span>
            </Button>
            <SettingsPanel
              showSettings={showSettings}
              onOpen={() => setShowSettings(true)}
              onClose={() => setShowSettings(false)}
              onShowOnboarding={() => {
                setOnboardingStep(0);
                setShowOnboarding(true);
              }}
              onShowScoring={() => setShowScoringModal(true)}
              onStartDailyChallenge={() => {
                setDailyChallenge(true);
                resetGame();
              }}
              dailyChallenge={dailyChallenge}
            />
          </div>
        </header>

        {/* Yesterday's Challenge */}
        {!gameActive && yesterdayChallengeData && yesterdayChallengeData.challenge && (
          <div className="mb-4 sm:mb-5">
            <YesterdayChallenge
              challengeData={yesterdayChallengeData}
              onViewSolution={(data) => {
                setYesterdayChallengeData(data);
                setShowYesterdaySolution(true);
              }}
            />
          </div>
        )}

        {/* User Stats Bar */}
        {!gameActive && (
          <UserStatsBar 
            username={username}
            onChangeUsername={() => setShowUsernameModal(true)}
          />
        )}

        {/* Hero Section - Only show on home screen */}
        {!gameActive && showHomeScreen && !showZenModeSelection && (
          <HeroSection 
            onStartRandomGame={() => {
              setShowHomeScreen(false);
              switchToRandomGame();
            }} 
            dailyChallenge={hasDailyChallenge}
            dailyChallengeHint={dailyChallengeHint}
            isDailyChallengeCompleted={isDailyChallengeCompleted}
            onStartDailyChallenge={() => {
              // Switch to daily challenge mode with minimized tiles
              setShowHomeScreen(false);
              setDailyChallenge(true);
              setShowZenModeSelection(false);
              setZenMode(false);
            }}
            onStartZenMode={() => {
              setShowHomeScreen(false);
              startZenMode();
            }}
            zenMode={zenMode && showZenModeSelection}
            username={username}
            onChangeUsername={() => setShowUsernameModal(true)}
            isAllZenModeCompleted={isAllZenModeCompleted}
          />
        )}

        {/* Minimized Game Mode Tiles - Show above Daily Challenge Setup */}
        {!gameActive && dailyChallenge && !showZenModeSelection && !showHomeScreen && (
          <div className="mb-4 sm:mb-6">
            <GameModeTiles
              onStartRandomGame={() => {
                setShowHomeScreen(false);
                switchToRandomGame();
              }}
              dailyChallenge={hasDailyChallenge}
              isDailyChallengeCompleted={isDailyChallengeCompleted}
              onStartDailyChallenge={() => {
                setDailyChallenge(true);
                setShowZenModeSelection(false);
                setZenMode(false);
                setShowHomeScreen(false);
                // Reset to show setup again
                setStartTitle("");
                setGoalTitle("");
                setStartSummary(null);
                setGoalSummary(null);
                resetGame();
              }}
              onStartZenMode={() => {
                setShowHomeScreen(false);
                startZenMode();
              }}
              isAllZenModeCompleted={isAllZenModeCompleted}
              minimized={true}
            />
          </div>
        )}

        {/* Minimized Game Mode Tiles - Show above Zen Mode Selection */}
        {showZenModeSelection && !gameActive && (
          <div className="mb-4 sm:mb-6 relative z-10">
            <GameModeTiles
              onStartRandomGame={async () => {
                // Close Zen Mode first
                setShowZenModeSelection(false);
                setZenMode(false);
                setShowHomeScreen(false);
                // Then switch to random game
                await switchToRandomGame();
              }}
              dailyChallenge={hasDailyChallenge}
              isDailyChallengeCompleted={isDailyChallengeCompleted}
              onStartDailyChallenge={() => {
                // Close Zen Mode and switch to Daily Challenge
                setShowZenModeSelection(false);
                setZenMode(false);
                setDailyChallenge(true);
                setShowHomeScreen(false);
                // Reset game state
                setStartTitle("");
                setGoalTitle("");
                setStartSummary(null);
                setGoalSummary(null);
                resetGame();
              }}
              onStartZenMode={() => {
                // Already in Zen Mode, do nothing or refresh
                setShowHomeScreen(false);
                startZenMode();
              }}
              isAllZenModeCompleted={isAllZenModeCompleted}
              minimized={true}
            />
          </div>
        )}

        {/* Zen Mode Selection */}
        {showZenModeSelection && !gameActive && (
          <Suspense fallback={
            <Card className="shadow-xl border-2">
              <CardContent className="p-4 sm:p-5">
                <div className="flex items-center justify-center py-8">
                  <Loader2 className="h-6 w-6 animate-spin" />
                </div>
              </CardContent>
            </Card>
          }>
            <ZenModeSelection
              practiceGames={zenModeGames}
              gameStatuses={zenModeGameStatuses}
              gameSummaries={zenModeGameSummaries}
              loading={loadingZenModeGames}
              onSelectGame={selectZenModeGame}
              onClose={() => {
                setShowZenModeSelection(false);
                setZenMode(false);
                setDailyChallenge(true);
                setShowHomeScreen(true);
                resetGame();
              }}
            />
          </Suspense>
        )}

        {!gameActive && (
        <>
          {/* Minimized Game Mode Tiles - Show above GameSetup for Random Mode */}
          {!showZenModeSelection && !dailyChallenge && !showHomeScreen && (
            <div className="mb-4 sm:mb-6">
              <GameModeTiles
                onStartRandomGame={() => {
                  setShowHomeScreen(false);
                  switchToRandomGame();
                }}
                dailyChallenge={hasDailyChallenge}
                isDailyChallengeCompleted={isDailyChallengeCompleted}
                onStartDailyChallenge={() => {
                  setDailyChallenge(true);
                  setShowHomeScreen(false);
                  resetGame();
                }}
                onStartZenMode={() => {
                  setShowHomeScreen(false);
                  startZenMode();
                }}
                isAllZenModeCompleted={isAllZenModeCompleted}
                minimized={true}
              />
            </div>
          )}

          {/* Game Setup - Only show when not on home screen and not in Zen Mode selection */}
          {!showHomeScreen && !showZenModeSelection && (
            <Suspense fallback={
              <Card className="shadow-xl border-2">
                <CardContent className="p-4 sm:p-5">
                  <div className="flex items-center justify-center py-8">
                    <Loader2 className="h-6 w-6 animate-spin" />
                  </div>
                </CardContent>
              </Card>
            }>
              <GameSetup
                dailyChallenge={dailyChallenge}
                startTitle={startTitle}
                goalTitle={goalTitle}
                startSummary={startSummary}
                goalSummary={goalSummary}
                startCategory={startCategory}
                goalCategory={goalCategory}
                won={won}
                startingGame={startingGame}
                gameActive={gameActive}
                timeUntilReset={timeUntilReset}
                loadingStartRandom={loadingStartRandom}
                loadingGoalRandom={loadingGoalRandom}
                onStartTitleChange={setStartTitle}
                onGoalTitleChange={setGoalTitle}
                onStartCategoryChange={setStartCategory}
                onGoalCategoryChange={setGoalCategory}
                onStartGame={startGame}
                onSwitchToRandomGame={switchToRandomGame}
                onSetDailyChallenge={setDailyChallenge}
                onResetGame={resetGame}
                onShowLeaderboard={() => setShowLeaderboard(true)}
                onLeaderboardRefresh={() => setLeaderboardRefreshKey(prev => prev + 1)}
                onSetError={setError}
                fetchRandomTitle={fetchRandomTitle}
                fetchRandomTitleFromCategory={fetchRandomTitleFromCategory}
              />
            </Suspense>
          )}
        </>
        )}

        {gameActive && articleHTML ? (
          <div className="flex flex-col lg:grid lg:grid-cols-[2fr,1.2fr,1.5fr] xl:grid-cols-[2.5fr,1.3fr,1.8fr] gap-3 sm:gap-4 lg:gap-4">
            {/* Left column: Full Wikipedia Article - Hidden on mobile by default */}
            <div className={`space-y-3 sm:space-y-4 lg:space-y-4 order-6 lg:order-1 ${showArticleOnMobile ? 'block' : 'hidden'} lg:block lg:min-w-0 lg:max-w-4xl xl:max-w-5xl`}>
              <Card className="shadow-sm lg:sticky lg:top-4">
                <CardHeader className="p-3 sm:p-4 lg:p-4">
                  <div className="flex items-center justify-between">
                    <CardTitle className="flex items-center gap-2 text-base sm:text-lg">
                      <Compass className="h-4 w-4 sm:h-5 sm:w-5" />
                      <span className="break-words">{summary?.title || currentTitle}</span>
                    </CardTitle>
                    <Button
                      variant="ghost"
                      size="icon"
                      onClick={() => setShowArticleOnMobile(false)}
                      className="lg:hidden h-8 w-8 sm:h-9 sm:w-9 min-w-[32px] sm:min-w-[36px]"
                      title="Hide article"
                    >
                      <EyeOff className="h-4 w-4" />
                    </Button>
                  </div>
                </CardHeader>
                <CardContent className="p-0">
                  <WikipediaArticleViewer 
                    html={articleHTML} 
                    onLinkClick={handleLinkClick}
                    theme={theme}
                  />
                </CardContent>
              </Card>
            </div>

            {/* Toggle button to show article on mobile - Only visible when article is hidden */}
            {!showArticleOnMobile && (
              <div className="order-6 lg:hidden">
                <Button
                  variant="outline"
                  onClick={() => setShowArticleOnMobile(true)}
                  className="w-full h-10 sm:h-11 flex items-center justify-center gap-2"
                >
                  <Eye className="h-4 w-4" />
                  <span>Show Wikipedia Article</span>
                </Button>
              </div>
            )}

            {/* Middle column: Game Controls */}
          <div className="space-y-3 sm:space-y-4 lg:space-y-4 order-4 lg:order-2">
            <Card className="shadow-sm">
              <CardHeader className="flex flex-col sm:flex-row items-start sm:items-center justify-between gap-2 sm:gap-0 p-3 sm:p-4 lg:p-4">
                <div className="flex items-center gap-2 sm:gap-3 flex-1 min-w-0">
                  {gameActive && history.length > 1 && (
                    <Button
                      variant="outline"
                      size="icon"
                      onClick={goBack}
                      className="flex-shrink-0 h-9 w-9 sm:h-10 sm:w-10 min-w-[36px] sm:min-w-[40px]"
                      title="Go back to previous page"
                    >
                      <ArrowLeft className="h-4 w-4" />
                    </Button>
                  )}
                    <CardTitle className="flex items-center gap-1.5 sm:gap-2 text-sm sm:text-base flex-1 min-w-0">
                    <Target className="h-4 w-4 sm:h-5 sm:w-5 flex-shrink-0" /> 
                    <span className="truncate">{goalTitle ? `Goal: ${goalTitle}` : "Pick a goal and start"}</span>
                  </CardTitle>
                </div>
                <div className="flex items-center gap-2 sm:gap-3 w-full sm:w-auto">
                  <Badge variant={won ? "default" : "secondary"} className="text-xs">
                    {won ? "Completed" : gameActive ? "In progress" : "Idle"}
                  </Badge>
                    <div className={`flex items-center gap-1 text-xs sm:text-sm ${
                      theme === 'dark' ? 'text-gray-200' : theme === 'classic' ? 'text-slate-700' : 'text-slate-600'
                    }`}>
                    <Timer className="h-3.5 w-3.5 sm:h-4 sm:w-4" /> {prettyTime(timer)}
                  </div>
                  {/* Zen Mode Forfeit Button */}
                  {zenMode && gameActive && !won && (
                    <Button
                      variant="outline"
                      onClick={handleZenModeForfeit}
                      className={`text-xs sm:text-sm h-8 sm:h-9 px-2 sm:px-3 ${
                        theme === 'dark'
                          ? 'border-amber-600/50 text-amber-300 hover:bg-amber-900/40'
                          : theme === 'classic'
                          ? 'border-amber-600 text-amber-700 hover:bg-amber-50'
                          : 'border-amber-400 text-amber-700 hover:bg-amber-50'
                      }`}
                    >
                      <Eye className="h-3.5 w-3.5 sm:h-4 sm:w-4 mr-1" />
                      Forfeit
                    </Button>
                  )}
                </div>
              </CardHeader>
              <CardContent className="p-3 sm:p-4 lg:p-4">
                {error && (
                    <div className={`mb-4 rounded-xl border p-3 text-sm ${
                      theme === 'dark'
                        ? 'border-red-800 bg-red-900/30 text-red-300'
                        : theme === 'classic'
                        ? 'border-red-600 bg-red-50 text-red-800'
                        : 'border-red-200 bg-red-50 text-red-700'
                    }`}>
                    {error}
                  </div>
                )}

                  {summary && (
                  <div className="space-y-3 sm:space-y-4">
                    <div className="flex gap-2 sm:gap-4">
                      {summary.thumbnail && (
                        <img src={summary.thumbnail} alt={summary.title} className="h-16 w-16 sm:h-20 sm:w-20 rounded-xl object-cover flex-shrink-0" />
                      )}
                      <div className="flex-1 min-w-0">
                          <div className={`text-lg sm:text-xl font-semibold break-words ${
                            theme === 'dark' ? 'text-white' : theme === 'classic' ? 'text-black' : 'text-slate-900'
                          }`}>
                            {summary.title}
                      </div>
                          <div className={`text-xs sm:text-sm ${
                            theme === 'dark' ? 'text-gray-300' : theme === 'classic' ? 'text-black' : 'text-slate-600'
                          }`}>
                            {summary.description}
                    </div>
                          <a className={`text-xs sm:text-sm underline touch-manipulation ${
                            theme === 'dark'
                              ? 'text-blue-400 hover:text-blue-300'
                              : theme === 'classic'
                              ? 'text-blue-600 visited:text-purple-600 hover:text-blue-800'
                              : 'text-blue-600 hover:text-blue-800'
                          }`} href={summary.url} target="_blank" rel="noreferrer">
                            Open on Wikipedia
                          </a>
                        </div>
                      </div>
                      <p className={`leading-relaxed text-xs sm:text-sm ${
                        theme === 'dark' ? 'text-gray-200' : theme === 'classic' ? 'text-black' : 'text-slate-700'
                      }`}>
                        {summary.extract}
                      </p>
                    <div className="space-y-2">
                        <div className={`text-xs sm:text-sm font-semibold mb-2 ${
                          theme === 'dark' ? 'text-gray-100' : theme === 'classic' ? 'text-black' : 'text-slate-900'
                        }`}>
                          Search links
                      </div>
                        <div className="flex gap-1.5 sm:gap-2">
                          <Input
                            type="text"
                            placeholder="Filter links..."
                            value={searchQuery}
                            onChange={(e) => setSearchQuery(e.target.value)}
                            className={`flex-1 h-9 sm:h-10 text-sm ${
                              theme === 'dark'
                                ? 'bg-slate-800 border-slate-700 text-white placeholder:text-slate-400'
                                : theme === 'classic'
                                ? 'bg-white border-slate-300 text-slate-900'
                                : 'bg-white border-slate-300 text-slate-900'
                            }`}
                          />
                          {searchQuery && (
                            <Button
                              variant="outline"
                              onClick={() => setSearchQuery("")}
                              className="flex-shrink-0 h-9 w-9 sm:h-10 sm:w-10 min-w-[36px] sm:min-w-[40px] p-0"
                            >
                              <X className="h-4 w-4" />
                            </Button>
                          )}
                        </div>
                    </div>

                    <div className="mt-4 sm:mt-6">
                        <div className={`mb-2 text-xs sm:text-sm font-semibold flex items-center justify-between ${
                          theme === 'dark' ? 'text-gray-100' : theme === 'classic' ? 'text-black' : 'text-slate-900'
                        }`}>
                          <span className="truncate">Available links {filteredLinks.length !== links.length && `(${filteredLinks.length}/${links.length})`}</span>
                        </div>
                        <div className="grid grid-cols-1 gap-1.5 sm:gap-2 max-h-[300px] sm:max-h-[400px] overflow-y-auto" style={{ WebkitOverflowScrolling: 'touch' }}>
                          {loading && (
                            <div className={`text-xs sm:text-sm ${
                              theme === 'dark' ? 'text-gray-300' : theme === 'classic' ? 'text-slate-600' : 'text-slate-500'
                            }`}>
                              Loading linksâ€¦
                            </div>
                          )}
                        {!loading && links.length === 0 && (
                            <div className={`text-xs sm:text-sm ${
                              theme === 'dark' ? 'text-gray-300' : theme === 'classic' ? 'text-slate-600' : 'text-slate-500'
                            }`}>
                              No links found on this page.
                            </div>
                          )}
                          {!loading && links.length > 0 && filteredLinks.length === 0 && (
                            <div className={`text-xs sm:text-sm ${
                              theme === 'dark' ? 'text-gray-300' : theme === 'classic' ? 'text-slate-600' : 'text-slate-500'
                            }`}>
                              No links match your search.
                            </div>
                        )}
                        {!loading &&
                            visibleLinks.map((l) => (
                              <Button 
                                key={l} 
                                variant="outline" 
                                className="justify-start text-left h-auto min-h-[44px] py-2 px-3 text-xs sm:text-sm break-words whitespace-normal" 
                                onClick={() => loadPage(l)}
                              >
                              {l}
                            </Button>
                          ))}
                          {!loading && filteredLinks.length > visibleLinksCount && (
                            <Button
                              variant="outline"
                              onClick={() => setVisibleLinksCount(prev => Math.min(prev + 100, filteredLinks.length))}
                              className={`w-full mt-2 ${
                                theme === 'dark'
                                  ? 'bg-slate-700 border-slate-600 text-gray-200 hover:bg-slate-600'
                                  : theme === 'classic'
                                  ? 'bg-white border-black text-black hover:bg-gray-100'
                                  : 'bg-slate-100 border-slate-300 text-slate-700 hover:bg-slate-200'
                              }`}
                            >
                              Load More ({filteredLinks.length - visibleLinksCount} remaining)
                            </Button>
                          )}
                      </div>
                    </div>
                  </div>
                )}
              </CardContent>
            </Card>
          </div>

            {/* Right column: Goal Summary and Steps */}
          <div className="flex flex-col gap-3 sm:gap-4 lg:gap-4 order-1 lg:order-3">
            {/* Goal Summary - 1st on mobile */}
            {gameActive && goalSummary && (
                <Card className={`shadow-sm border-2 order-1 ${
                  theme === 'dark'
                    ? 'border-gray-700 bg-gray-800/50'
                    : theme === 'classic'
                    ? 'border-blue-600 bg-blue-50'
                    : 'border-blue-200 bg-blue-50/50'
                }`}>
                <CardHeader className="p-3 sm:p-4 lg:p-4">
                  <CardTitle className="flex items-center gap-1.5 sm:gap-2 text-sm sm:text-base">
                      <Flag className={`h-4 w-4 sm:h-5 sm:w-5 ${
                        theme === 'dark' ? 'text-gray-300' : 'text-blue-600'
                      }`} />
                      <span className={theme === 'dark' ? 'text-gray-200' : 'text-blue-900'}>
                        Goal Article
                      </span>
                  </CardTitle>
                </CardHeader>
                <CardContent className="space-y-2 sm:space-y-3 p-3 sm:p-4 lg:p-4">
                  <div className="flex gap-2 sm:gap-3">
                    {goalSummary.thumbnail && (
                      <img src={goalSummary.thumbnail} alt={goalSummary.title} className="h-16 w-16 sm:h-20 sm:w-20 rounded-lg object-cover flex-shrink-0" />
                    )}
                    <div className="flex-1 min-w-0">
                        <div className={`font-semibold text-sm sm:text-base break-words ${
                          theme === 'dark' ? 'text-white' : 'text-slate-900'
                        }`}>
                          {goalSummary.title}
                        </div>
                      {goalSummary.description && (
                          <div className={`text-xs sm:text-sm mt-1 ${
                            theme === 'dark' ? 'text-gray-200' : 'text-slate-600'
                          }`}>
                            {goalSummary.description}
                          </div>
                      )}
                    </div>
                  </div>
                  {goalSummary.extract && (
                      <p className={`text-xs sm:text-sm leading-relaxed ${
                        theme === 'dark' ? 'text-gray-200' : 'text-slate-700'
                      }`}>
                        {goalSummary.extract}
                      </p>
                    )}
                    <a 
                      className={`text-xs sm:text-sm underline inline-block touch-manipulation ${
                        theme === 'dark'
                          ? 'text-blue-400 hover:text-blue-300'
                          : theme === 'classic'
                          ? 'text-blue-600 visited:text-purple-600 hover:text-blue-800'
                          : 'text-blue-600 hover:text-blue-800'
                      }`}
                    href={goalSummary.url} 
                    target="_blank" 
                    rel="noreferrer"
                  >
                    Open on Wikipedia â†’
                  </a>
                </CardContent>
              </Card>
            )}

            {/* Steps Taken - 2nd on mobile */}
            {gameActive && history.length > 0 && (
            <Card className="shadow-sm order-2">
                <CardHeader className="p-3 sm:p-4 lg:p-4">
                  <CardTitle className="flex items-center gap-1.5 sm:gap-2 text-sm sm:text-base">
                    <History className="h-4 w-4 sm:h-5 sm:w-5" />
                    Steps Taken ({moveCount})
                  </CardTitle>
                </CardHeader>
                <CardContent className="p-3 sm:p-4 lg:p-4">
                  <div className="space-y-1.5 sm:space-y-2 max-h-[400px] sm:max-h-[500px] overflow-y-auto" style={{ WebkitOverflowScrolling: 'touch' }}>
                    {history.map((article, index) => (
                      <button
                        key={index}
                        onClick={() => navigateToStep(index)}
                          className={`w-full flex items-center gap-2 sm:gap-3 p-2 sm:p-3 rounded-lg transition-colors cursor-pointer text-left touch-manipulation min-h-[44px] ${
                            theme === 'dark'
                              ? 'bg-slate-800 hover:bg-slate-700 active:bg-slate-600'
                              : theme === 'classic'
                              ? 'bg-slate-100 hover:bg-blue-100 active:bg-blue-200 border border-slate-300'
                              : 'bg-slate-50 hover:bg-slate-200 active:bg-slate-300'
                          }`}
                        >
                          <div className={`flex-shrink-0 w-7 h-7 sm:w-8 sm:h-8 rounded-full flex items-center justify-center text-xs sm:text-sm font-semibold ${
                            theme === 'dark'
                              ? 'bg-slate-700 text-slate-200'
                              : theme === 'classic'
                              ? 'bg-slate-300 text-slate-900'
                              : 'bg-slate-200 text-slate-700'
                          }`}>
                          {index + 1}
                        </div>
                        <div className="flex-1 min-w-0">
                            <div className={`font-medium text-xs sm:text-sm break-words ${
                              theme === 'dark' ? 'text-white' : 'text-slate-900'
                            }`}>
                              {article}
                            </div>
                            {index === 0 && (
                              <div className={`text-xs mt-0.5 sm:mt-1 ${
                                theme === 'dark' ? 'text-gray-300' : 'text-slate-500'
                              }`}>
                                Start
                              </div>
                            )}
                            {index === history.length - 1 && (
                              <div className={`text-xs mt-0.5 sm:mt-1 font-semibold ${
                                theme === 'dark' ? 'text-green-400' : 'text-green-600'
                              }`}>
                                Current
                              </div>
                            )}
                        </div>
                        {index < history.length - 1 && (
                            <div className={`flex-shrink-0 ${theme === 'dark' ? 'text-gray-400' : 'text-slate-400'}`}>
                            <svg className="w-4 h-4 sm:w-5 sm:h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
                            </svg>
                          </div>
                        )}
                      </button>
                    ))}
                  </div>
                </CardContent>
              </Card>
            )}
          </div>
        </div>
        ) : (
        <div className="space-y-3 sm:space-y-4 lg:space-y-6">
          {/* Game Status Card - Only show when there's content or game is active */}
          {(summary || error || gameActive) && (
          <Card className="shadow-sm">
            <CardHeader className="flex flex-row items-center justify-between">
              <div className="flex items-center gap-3">
                {gameActive && history.length > 1 && (
                  <Button
                    variant="outline"
                    size="icon"
                    onClick={goBack}
                    className="flex-shrink-0"
                    title="Go back to previous page"
                  >
                    <ArrowLeft className="h-4 w-4" />
                  </Button>
                )}
                <CardTitle className="flex items-center gap-2">
                  <Target className="h-5 w-5" /> {goalTitle ? `Goal: ${goalTitle}` : "Pick a goal and start"}
                </CardTitle>
              </div>
              <div className="flex items-center gap-3">
                <Badge variant={won ? "default" : "secondary"} className="text-xs">
                  {won ? "Completed" : gameActive ? "In progress" : "Idle"}
                </Badge>
                <div className={`flex items-center gap-1 text-sm ${
                  theme === 'dark' ? 'text-gray-200' : theme === 'classic' ? 'text-slate-700' : 'text-slate-600'
                }`}>
                  <Timer className="h-4 w-4" /> {prettyTime(timer)}
                </div>
              </div>
            </CardHeader>
            <CardContent>
              {error && (
                <div className={`mb-4 rounded-xl border p-3 text-sm ${
                  theme === 'dark'
                    ? 'border-red-800 bg-red-900/30 text-red-300'
                    : theme === 'classic'
                    ? 'border-red-600 bg-red-50 text-red-800'
                    : 'border-red-200 bg-red-50 text-red-700'
                }`}>
                  {error}
                </div>
              )}

              {summary ? (
                <div className="space-y-4">
                  <div className="flex gap-4">
                    {summary.thumbnail && (
                      <img src={summary.thumbnail} alt={summary.title} className="h-20 w-20 rounded-xl object-cover" />
                    )}
                    <div>
                      <div className={`text-xl font-semibold ${
                        theme === 'dark' ? 'text-white' : theme === 'classic' ? 'text-black' : 'text-slate-900'
                      }`}>
                        {summary.title}
                      </div>
                      <div className={`text-sm ${
                        theme === 'dark' ? 'text-gray-300' : theme === 'classic' ? 'text-black' : 'text-slate-600'
                      }`}>
                        {summary.description}
                      </div>
                      <a className={`text-sm underline ${
                        theme === 'dark'
                          ? 'text-blue-400 hover:text-blue-300'
                          : theme === 'classic'
                          ? 'text-blue-600 visited:text-purple-600 hover:text-blue-800'
                          : 'text-blue-600 hover:text-blue-800'
                      }`} href={summary.url} target="_blank" rel="noreferrer">
                        Open on Wikipedia
                      </a>
                    </div>
                  </div>
                  <p className={`leading-relaxed ${
                    theme === 'dark' ? 'text-gray-200' : theme === 'classic' ? 'text-black' : 'text-slate-700'
                  }`}>
                    {summary.extract}
                  </p>
                  <div className="space-y-2">
                    <div className={`text-sm font-semibold mb-2 ${
                      theme === 'dark' ? 'text-gray-100' : theme === 'classic' ? 'text-black' : 'text-slate-900'
                    }`}>
                      Search links
                    </div>
                    <div className="flex gap-2">
                      <Input
                        type="text"
                        placeholder="Filter available links..."
                        value={searchQuery}
                        onChange={(e) => setSearchQuery(e.target.value)}
                        className={`flex-1 ${
                          theme === 'dark'
                            ? 'bg-slate-800 border-slate-700 text-white placeholder:text-slate-400'
                            : theme === 'classic'
                            ? 'bg-white border-slate-300 text-slate-900'
                            : 'bg-white border-slate-300 text-slate-900'
                        }`}
                      />
                      {searchQuery && (
                        <Button
                          variant="outline"
                          onClick={() => setSearchQuery("")}
                          className="flex-shrink-0"
                        >
                          <X className="h-4 w-4" />
                        </Button>
                      )}
                    </div>
                  </div>

                  <div className="mt-6">
                    <div className={`mb-2 text-sm font-semibold flex items-center justify-between ${
                      theme === 'dark' ? 'text-gray-100' : theme === 'classic' ? 'text-black' : 'text-slate-900'
                    }`}>
                      <span>Available links {filteredLinks.length !== links.length && `(${filteredLinks.length} of ${links.length})`}</span>
                    </div>
                    <div className="grid grid-cols-1 gap-2 max-h-[400px] overflow-y-auto">
                      {loading && (
                        <div className={`text-sm ${
                          theme === 'dark' ? 'text-gray-300' : theme === 'classic' ? 'text-slate-600' : 'text-slate-500'
                        }`}>
                          Loading linksâ€¦
                        </div>
                      )}
                      {!loading && links.length === 0 && (
                        <div className={`text-sm ${
                          theme === 'dark' ? 'text-gray-300' : theme === 'classic' ? 'text-slate-600' : 'text-slate-500'
                        }`}>
                          No links found on this page.
                        </div>
                      )}
                      {!loading && links.length > 0 && filteredLinks.length === 0 && (
                        <div className={`text-sm ${
                          theme === 'dark' ? 'text-gray-300' : theme === 'classic' ? 'text-slate-600' : 'text-slate-500'
                        }`}>
                          No links match your search.
                        </div>
                      )}
                      {!loading &&
                        visibleLinks.map((l) => (
                          <Button key={l} variant="outline" className="justify-start text-left" onClick={() => loadPage(l)}>
                            {l}
                          </Button>
                        ))}
                      {!loading && filteredLinks.length > visibleLinksCount && (
                        <Button
                          variant="outline"
                          onClick={() => setVisibleLinksCount(prev => Math.min(prev + 100, filteredLinks.length))}
                          className={`w-full mt-2 ${
                            theme === 'dark'
                              ? 'bg-slate-700 border-slate-600 text-gray-200 hover:bg-slate-600'
                              : theme === 'classic'
                              ? 'bg-white border-black text-black hover:bg-gray-100'
                              : 'bg-slate-100 border-slate-300 text-slate-700 hover:bg-slate-200'
                          }`}
                        >
                          Load More ({filteredLinks.length - visibleLinksCount} remaining)
                        </Button>
                      )}
                    </div>
                  </div>
                </div>
              ) : (
                <div className={`text-sm ${
                  theme === 'dark' ? 'text-gray-300' : theme === 'classic' ? 'text-black' : 'text-slate-600'
                }`}>
                  Click <span className="font-medium">Start</span> to randomize (or use your own) start/goal and begin the journey.
                </div>
              )}
            </CardContent>
          </Card>
          )}
        </div>
      )}

        <footer className={`text-xs text-center pt-4 pb-2 flex items-center justify-center gap-2 flex-wrap ${
          theme === 'dark' ? 'text-gray-300' : theme === 'classic' ? 'text-slate-600' : 'text-slate-500'
        }`}>
          <span>Uses the public Wikipedia API. Be kind to Wikimedia servers.</span>
          <span className="flex items-center gap-1">
            <Heart className="h-3 w-3 fill-red-500 text-red-500" />
            <span>Made in India</span>
          </span>
        </footer>
      </div>

      {/* Victory Summary Screen */}
      <Suspense fallback={
        <div className="fixed inset-0 bg-black/70 backdrop-blur-sm z-[60] flex items-center justify-center">
          <Loader2 className="h-8 w-8 animate-spin text-white" />
        </div>
      }>
        <GameResults
          won={won}
          finalScore={finalScore}
          moveCount={moveCount}
          finalTime={finalTime}
          timer={timer}
          history={history}
          startTitle={startTitle}
          goalTitle={goalTitle}
          username={username}
          isChallengeMode={isChallengeMode}
          challengeData={challengeData}
          dailyChallenge={dailyChallenge}
          showScoreBreakdown={showScoreBreakdown}
          setShowScoreBreakdown={setShowScoreBreakdown}
          submittingScore={submittingScore}
          scoreSubmitted={scoreSubmitted}
          setShowLeaderboard={setShowLeaderboard}
          setLeaderboardRefreshKey={setLeaderboardRefreshKey}
          setShowUsernameModal={setShowUsernameModal}
          submitToLeaderboard={submitToLeaderboard}
          resetGame={resetGame}
        />
      </Suspense>

      {/* Starting Game Loading Overlay */}
      {startingGame && (
        <div className="fixed inset-0 bg-black/60 backdrop-blur-sm z-50 flex items-center justify-center p-4">
          <Card className="w-full max-w-md shadow-2xl">
            <CardContent className="p-6 sm:p-8 flex flex-col items-center justify-center space-y-4">
              <Loader2 className="h-12 w-12 sm:h-16 sm:w-16 animate-spin text-blue-600 dark:text-blue-400" />
              <div className="text-center space-y-2">
                <h3 className={`text-lg sm:text-xl font-semibold ${
                  theme === 'dark' ? 'text-white' : 'text-slate-900'
                }`}>
                  Starting Game...
                </h3>
                <p className={`text-sm sm:text-base ${
                  theme === 'dark' ? 'text-gray-300' : 'text-slate-600'
                }`}>
                  {dailyChallenge 
                    ? "Loading today's challenge articles..." 
                    : "Fetching articles and loading Wikipedia pages..."}
                </p>
              </div>
            </CardContent>
          </Card>
        </div>
      )}

      {/* Challenge Screen Modal */}
      <Suspense fallback={null}>
        <ChallengeScreen
          showChallengeScreen={showChallengeScreen && !!challengeData}
          challengeData={challengeData}
          onDecline={() => {
            setShowChallengeScreen(false);
            setIsChallengeMode(false);
            setChallengeData(null);
            // Clear URL parameters
            window.history.replaceState({}, '', window.location.pathname);
            // Show onboarding if needed after dismissing challenge
            const hasSeenOnboarding = localStorage.getItem('wikiGo-onboarding-seen');
            if (!hasSeenOnboarding) {
              setShowOnboarding(true);
            }
          }}
          onAccept={async () => {
            // Close challenge screen and set starting flag immediately
            setShowChallengeScreen(false);
            setStartingGame(true);
            try {
              await startGame();
            } catch (err) {
              console.error('Error starting challenge game:', err);
              setError("Failed to start challenge. Please try again.");
              setStartingGame(false);
              // Re-show challenge screen if there was an error
              setShowChallengeScreen(true);
            }
          }}
        />
      </Suspense>

      {/* Onboarding Modal */}
      <Suspense fallback={null}>
        <Onboarding
          showOnboarding={showOnboarding}
          onboardingStep={onboardingStep}
          setOnboardingStep={setOnboardingStep}
          onClose={() => {
            localStorage.setItem('wikiGo-onboarding-seen', 'true');
            setShowOnboarding(false);
          }}
        />
      </Suspense>

      {/* Scoring Methodology Modal */}
      <Suspense fallback={null}>
        <ScoringMethodology
          showScoringModal={showScoringModal}
          onClose={() => setShowScoringModal(false)}
        />
      </Suspense>

      {/* Username Modal */}
      {showUsernameModal && (
        <div className="fixed inset-0 bg-black/70 backdrop-blur-sm z-[60] flex items-center justify-center p-4">
          <Card className="w-full max-w-md shadow-2xl">
            <CardHeader className="p-4 sm:p-6">
              <div className="flex items-center justify-between">
                <CardTitle className="text-lg sm:text-xl">Set Your Username</CardTitle>
                <Button
                  variant="ghost"
                  size="icon"
                  onClick={() => {
                    setShowUsernameModal(false);
                    setUsernameInput("");
                  }}
                  className="h-8 w-8 sm:h-10 sm:w-10"
                >
                  <X className="h-4 w-4 sm:h-5 sm:w-5" />
                </Button>
              </div>
            </CardHeader>
            <CardContent className="p-4 sm:p-6 space-y-4">
              <p className={`text-sm ${
                theme === 'dark' ? 'text-gray-300' : theme === 'classic' ? 'text-black' : 'text-slate-600'
              }`}>
                {pendingSubmission 
                  ? "Choose a username to display on the leaderboard before submitting your score, or keep your current one."
                  : "Choose a username to display on the leaderboard, or use your current one."}
              </p>
              <div className="space-y-2">
                <Input
                  placeholder="Enter username"
                  value={usernameInput}
                  onChange={(e) => setUsernameInput(e.target.value)}
                  maxLength={30}
                  className="text-sm"
                />
                <div className={`text-xs ${
                  theme === 'dark' ? 'text-gray-400' : theme === 'classic' ? 'text-black' : 'text-slate-500'
                }`}>
                  Current: <strong>{username}</strong>
                </div>
              </div>
              <div className="flex gap-2">
                <Button
                  variant="outline"
                  onClick={() => {
                    setShowUsernameModal(false);
                    setUsernameInput("");
                  }}
                  className="flex-1"
                >
                  Cancel
                </Button>
                <Button
                  onClick={async () => {
                    const newUsername = usernameInput.trim() || username;
                    if (newUsername && newUsername !== username) {
                      const oldUsername = username;
                      // Update username across all database tables
                      await updateUsernameAcrossTables(oldUsername, newUsername);
                      setStoredUsername(newUsername, false); // Mark as user-set
                      setUsername(newUsername);
                      setShowUsernameModal(false);
                      setUsernameInput("");
                      setPendingSubmission(false);
                      // Submit score after username is confirmed
                      if (won && dailyChallenge && finalTime.current > 0 && !scoreSubmitted) {
                        submitToLeaderboard();
                      }
                    } else if (newUsername === username) {
                      // Username didn't change, just close modal
                      setShowUsernameModal(false);
                      setUsernameInput("");
                      setPendingSubmission(false);
                      // Submit score if needed
                      if (won && dailyChallenge && finalTime.current > 0 && !scoreSubmitted) {
                        submitToLeaderboard();
                      }
                    }
                  }}
                  className="flex-1"
                  disabled={!usernameInput.trim() && username}
                >
                  {pendingSubmission ? 'Save & Submit Score' : 'Save'}
                </Button>
              </div>
            </CardContent>
          </Card>
        </div>
      )}

      {/* Leaderboard Modal */}
      {showLeaderboard && (
        <div className="fixed inset-0 bg-black/70 backdrop-blur-sm z-[60] flex items-center justify-center p-4 overflow-y-auto">
          <Card className="w-full max-w-2xl max-h-[90vh] overflow-hidden shadow-2xl flex flex-col my-4">
            <CardHeader className="relative p-4 sm:p-6 border-b flex-shrink-0">
              <div className="flex items-center justify-between">
                <CardTitle className="flex items-center gap-2 text-lg sm:text-xl">
                  <Users className="h-5 w-5 sm:h-6 sm:w-6" />
                  Leaderboard
                </CardTitle>
                <div className="flex items-center gap-2">
                  <Button
                    variant="ghost"
                    size="icon"
                    onClick={() => {
                      setShowUsernameModal(true);
                      setShowLeaderboard(false);
                    }}
                    className="h-8 w-8 sm:h-10 sm:w-10"
                    title="Change username"
                  >
                    <Edit2 className="h-4 w-4 sm:h-5 sm:w-5" />
                  </Button>
                  <Button
                    variant="ghost"
                    size="icon"
                    onClick={() => setShowLeaderboard(false)}
                    className="h-8 w-8 sm:h-10 sm:w-10"
                  >
                    <X className="h-4 w-4 sm:h-5 sm:w-5" />
                  </Button>
                </div>
              </div>
            </CardHeader>
            <CardContent className="flex-1 overflow-y-auto p-4 sm:p-6">
              <Leaderboard key={leaderboardRefreshKey} onRefresh={submittingScore} />
            </CardContent>
          </Card>
        </div>
      )}

      {/* Yesterday's Solution Modal */}
      {showYesterdaySolution && yesterdayChallengeData && (
        <YesterdaySolution
          challengeData={yesterdayChallengeData}
          onClose={() => setShowYesterdaySolution(false)}
          onReplay={() => {
            if (yesterdayChallengeData && yesterdayChallengeData.challenge) {
              // Set up challenge mode with yesterday's articles
              setChallengeData({
                start: yesterdayChallengeData.challenge.startTitle,
                end: yesterdayChallengeData.challenge.goalTitle,
              });
              setIsChallengeMode(true);
              setShowYesterdaySolution(false);
              resetGame();
              // Start the game with yesterday's challenge
              setTimeout(() => {
                startGame();
              }, 100);
            }
          }}
        />
      )}

      {/* Zen Mode Solution Modal - Only show for forfeits, not for completed games */}
      {showZenModeSolution && zenModeSolutionData && !zenModeSolutionCompleted && (
        <Suspense fallback={null}>
          <ZenModeSolution
            gameData={zenModeSolutionData}
            isCompleted={false}
            onClose={() => {
              setShowZenModeSolution(false);
              setZenModeSolutionData(null);
              // Show selection screen again
              if (zenMode) {
                setShowZenModeSelection(true);
              }
            }}
          />
        </Suspense>
      )}
    </div>
  );
}


